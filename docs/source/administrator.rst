Administrator Guide
====================

Authenticators
---------------

DummyAuthenticator
^^^^^^^^^^^^^^^^^^^

.. code-block:: python

    from grader_service.auth.dummy import DummyAuthenticator
    c.GraderService.authenticator_class = DummyAuthenticator

    c.DummyAuthenticator.password = 'test'
    # c.Authenticator.allowed_users = {'instructor', 'tutor', 'student1', 'student2'}
    c.Authenticator.allow_all = True


PAMAuthenticator
^^^^^^^^^^^^^^^^^^

Uses `PAM <https://en.wikipedia.org/wiki/Pluggable_authentication_module>`_-based authentication to log in local system users.

 .. code-block:: python

    from grader_service.auth.pam import PAMAuthenticator
    c.GraderService.authenticator_class = PAMAuthenticator



OAuthenticator
^^^^^^^^^^^^^^^^

Example configuration for ``grader_service_config.py`` using Google OAuth.

.. code-block:: python

    from grader_service.auth.oauth2 import OAuthenticator
    c.GraderService.authenticator_class = OAuthenticator

    c.OAuthenticator.client_id = "<client_id>"
    c.OAuthenticator.client_secret = "<client_secret>"
    c.OAuthenticator.authorize_url = "https://accounts.google.com/o/oauth2/auth"
    c.OAuthenticator.token_url = "https://oauth2.googleapis.com/token"
    c.OAuthenticator.scope = ['email']

    c.OAuthenticator.userdata_url = "https://www.googleapis.com/oauth2/v1/userinfo"
    c.OAuthenticator.username_claim = "email"



LTI 1.3 Authenticator
^^^^^^^^^^^^^^^^^^^^^^^

Log in using the LTI authentication flow. This example configuration is based on a local Moodle setup based on `moodle-docker <https://github.com/moodlehq/moodle-docker>`_.

.. code-block:: python

    c.LTI13Authenticator.issuer = "http://localhost:8000"
    c.LTI13Authenticator.authorize_url = "http://localhost:8000/mod/lti/auth.php"
    # The platform's JWKS endpoint url providing public key sets used to verify the ID token
    c.LTI13Authenticator.jwks_endpoint = "http://localhost:8000/mod/lti/certs.php"
    # The external tool's client id as represented within the platform (LMS)
    c.LTI13Authenticator.client_id = ["<client_id>"]  # generated by Moodle etc. after creating external tool


In Moodle itself the external tool configuration is as follows, given that the Grader Service runs on ``localhost:4010`` and JupyterHub runs on ``localhost:8080``.

Tool URL: ::

    http://localhost:4010/?next=http%3A%2F%2Flocalhost%3A8080

This becomes the ``target_link_uri`` of the login request. If this contains a ``next`` URL query parameter, it is extracted and used by the Grader Service to redirect after the authentication flow.
In this case we redirect to ``http://localhost:8080``, which is the JupyterHub.

LTI version: ::

    LTI 1.3

Public key type: ::

    Keyset URL

The ``Public keyset`` field can be left empty.

Initiate login URL: ::

    http://localhost:4010/services/grader/lti13/oauth_login

The login handler of the Grader Service.

Redirection URI(s): ::

    http://localhost:4010/services/grader/lti13/oauth_callback

The callback handler for the OAuth flow.


Configuration for JupyterHub
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

After authentication is complete the Grader Service will redirect to the JupyterHub (as specified in the ``Tool URL``), from which the user is authenticated via OAuth.
JupyterHub now uses the Grader Service as an IDP using its OAuthenticator implementation.

.. code-block:: python

    from oauthenticator.generic import GenericOAuthenticator

    c.JupyterHub.authenticator_class = GenericOAuthenticator
    c.GenericOAuthenticator.oauth_callback_url = "http://localhost:8080/hub/oauth_callback"

    c.GenericOAuthenticator.client_id = "hub"
    c.GenericOAuthenticator.client_secret = "hub"
    c.GenericOAuthenticator.authorize_url = "http://localhost:4010/services/grader/api/oauth2/authorize"
    c.GenericOAuthenticator.token_url = "http://localhost:4010/services/grader/api/oauth2/token"

    c.GenericOAuthenticator.userdata_url = "http://localhost:4010/services/grader/api/user"
    c.GenericOAuthenticator.username_claim = "name"


In the Grader Service config the JupyterHub has to be registered as a client.

.. code-block:: python

    c.GraderService.oauth_clients = [{
        'client_id': 'hub',
        'client_secret': 'hub',
        'redirect_uri': 'http://localhost:8080/hub/oauth_callback'
    }]




Authenticating the Lab-Extension
----------------------------------

Without any configuration, the Grader Lab-Extension has no way to access the authentication information.
JupyterHub allows us to pass the ``access_token`` that we received during the OAuth flow with the Grader Service to the environment of the notebook server.
The Lab-Extension then uses this token in the environment variable ``GRADER_API_TOKEN`` to authenticate itself with the Grader Service. A sample configuration can be seen below:

.. code-block:: python

    c.Authenticator.enable_auth_state = True


    def userdata_hook(spawner, auth_state):
        token = auth_state["access_token"]

        # The environment variable GRADER_API_TOKEN is used by the lab-extension
        # to identify the user in API calls to the Grader Service.
        spawner.environment.update({"GRADER_API_TOKEN": token})


    # We have access to the authentication data, which we can use to set
    # `userdata` in the spawner of the user.
    c.Spawner.auth_state_hook = userdata_hook



Assigning Users to Roles based on Authentication Info
------------------------------------------------------

Grader Service supports the ``load_roles`` config option to pre-load certain roles in the beginning.
However, this information should most likely be updated based on the authentication info received from the external authentication/authorization provider.
The achieve this, the ``post_auth_hook`` from the ``Authenticator`` class can be used to specify this behaviour.
In this case we are using the LTI 1.3 authenticator and map every user the has an instructor role defined by the IMS standard to Instructors in the Grader Service.


.. code-block:: python

    def get_role_from_auth(auth_state):
    user_role = 'student'
    for role in auth_state['https://purl.imsglobal.org/spec/lti/claim/roles']:
        if role.find('Instructor') >= 1:
            user_role = 'instructor'
            break
    return user_role


    def post_auth_hook(authenticator: Authenticator, handler: BaseHandler, authentication: dict):
        print("####### POST AUTH HOOK")
        session = handler.session
        log = handler.log
        auth_state = authentication["auth_state"]

        username = authentication["name"]
        user_model: User = session.query(User).get(username)
        if user_model is None:
            user_model = User()
            user_model.name = username
            session.add(user_model)
            session.commit()

        lecture_code = auth_state["https://purl.imsglobal.org/spec/lti/claim/context"]["label"].replace(" ", "")
        lecture = session.query(Lecture).filter(Lecture.code == lecture_code).one_or_none()
        if lecture is None:
            lecture = Lecture()
            lecture.code = lecture_code
            lecture.name = lecture_code
            lecture.state = LectureState.active
            lecture.deleted = DeleteState.active
            session.add(lecture)
            session.commit()

        lti_role = get_role_from_auth(auth_state)
        scope = Scope[lti_role.lower()]
        log.info(f'Determined role {scope.name} for user {username}')

        role = session.query(Role).filter(Role.username == username, Role.lectid == lecture.id).one_or_none()
        if role is None:
            log.info(f'No role for user {username} in lecture {lecture_code}... creating role')
            role = Role(username=username, lectid=lecture.id, role=scope)
            session.add(role)
            session.commit()
        else:
            log.info(f'Found role {role.role.name} for user {username}  in lecture {lecture_code}... updating role to {scope.name}')
            role.role = scope
            session.commit()

        return authentication


    c.Authenticator.post_auth_hook = post_auth_hook


Task Queue
---------------

..  TODO: grader service uses celery task queue with rabbit mq as broker -> refer to rabbit mq docs to run locally
        run rabbit mq + grader service worker as additional processes
    TODO: refer to examples/k8s to see how rabbit mq is set up in deployment

How To Scale
---------------

.. TODO: after it runs locally how to scale up to k8s deployment? what to consider when doing so? helm commands/values? describe local k8s deployment (minikube etc.) using examples
    TODO: write test cases for examples (at least for local dev_environment)
